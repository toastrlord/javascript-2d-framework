<!DOCTYPE html>
<meta charset="UTF-8">
<html>
    <link rel='stylesheet' href='style.css'>
    <head>
        <script id='clipspace-vertex-shader-2d' type='glsl'>
            // simple vertex shader, expecting positions to be in clipspace
            // attribute will receive data from a buffer
            attribute vec4 a_position;

            //all shaders have a main function
            void main() {
                // gl_Position is a special var for a vertex shaders
                gl_Position = a_position;
            }
        </script>
        <script id='pixel-vertex-shader-2d' type='glsl'>
            // vertex shader that expects positions in pixel-vertex-shader-2d, uses bottom-left origin
            attribute vec2 a_position;
            attribute vec4 a_color;

            varying vec4 v_color;

            uniform vec2 u_resolution;

            void main() {
                // pixel value (x or y) => clipspace value
                // 0 => -1
                // res/2 => 0
                // res => 1
                // take pixel value, divide by resolution (mapping from 0 to 1)
                // then, subtract 0.5 and multiply by 2, to go from a 0->1 mapping to -1->1
                vec2 zeroToOne = a_position / u_resolution; //range: [0, 1]
                vec2 minusPointFive = zeroToOne - 0.5; //range: [-.5, .5]
                vec2 clipSpace = minusPointFive * 2.0; //range: [-1, 1]
                gl_Position = vec4(clipSpace, 0, 1);
                v_color = a_color;
            }
        </script>
        <script id='image-vertex-shader-2d' type='glsl'>
            // vertex shader that takes a unit square, and scales it via matrix math
            // (faster than uploading sevaral vertices to the GPU)
            attribute vec2 a_position;
            attribute vec2 a_texcoord;

            uniform vec2 u_resolution;
            uniform mat3 u_matrix;

            varying vec2 v_texcoord;
            
            void main() {
            // Multiply the position by the matrix.
            vec2 position = (u_matrix * vec3(a_position, 1)).xy;
            
            // convert the position from pixels to 0.0 to 1.0
            vec2 zeroToOne = a_position / u_resolution; //range: [0, 1]
            vec2 minusPointFive = zeroToOne - 0.5; //range: [-.5, .5]
            vec2 clipSpace = minusPointFive * 2.0; //range: [-1, 1]
            
            // convert from 0->1 to 0->2
            //vec2 zeroToTwo = zeroToOne * 2.0;
            
            // convert from 0->2 to -1->+1 (clipspace)
            //vec2 clipSpace = zeroToTwo - 1.0;
            
            v_texcoord = a_texcoord;
            gl_Position = vec4(clipSpace, 0, 1);
            }
        </script>
        <script id='image-fragment-shader-2d' type='glsl'>
            precision mediump float;

            varying vec2 v_texcoord;

            uniform sampler2D u_texture;

            void main() {
                gl_FragColor = texture2D(u_texture, v_texcoord);
            }
        </script>
        <script id='static-color-fragment-shader-2d' type='glsl'>
            // fragment shaders do not have a default precision
            // so it needs to be set here
            precision mediump float;

            void main() {
                // gl_FragColor is a special var for fragment shaders
                gl_FragColor = vec4(1, 0, 0.5, 1); //reddish-purple color
            }
        </script>
        <script id='uniform-color-fragment-shader-2d' type='glsl'>
            precision mediump float;

            uniform vec4 u_color;

            void main() {
                gl_FragColor = u_color;
            }
        </script>
        <script id='color-fragment-shader-2d' type='glsl'>
            precision mediump float;

            varying vec4 v_color;

            void main() {
                gl_FragColor = v_color;
            }
        </script>
    </head>
        <body>
            <canvas id="canvas">
                Canvas error!
            </canvas>
            <script src="main.js"></script>
        </body>
</html>