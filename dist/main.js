/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _webgl_test__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-test */ \"./src/webgl-test.js\");\n/* harmony import */ var _matrix_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix-util */ \"./src/matrix-util.js\");\n\n;\n\n\nconst canvas = document.querySelector('#canvas');\nconst width = canvas.width;\nconst height = canvas.height;\nlet points = [\n    0, 0,\n    150, 0,\n    150, 75,\n    150, 75,\n    300, 75,\n    300, 150,\n    150, 0,\n    300, 0,\n    300, 75,\n];\n\nlet triforce = [\n    0, 0,\n    150, 0,\n    75, 75,\n    150, 0,\n    225, 75,\n    300, 0,\n    75, 75,\n    225, 75,\n    150, 150,\n];\n\nlet clearColor = [\n    0,\n    0,\n    0,\n    0\n]\n\nlet yellow = [\n    1,\n    1,\n    0,\n    1\n];\n\nfunction sameColor(positions, color) {\n    let result = [];\n    for (let i = 0; i < positions.length; i += 2) {\n        result.push(...color);\n    }\n    return result;\n}\n\n/**\n * \n * @param {number} x \n * @param {number} y \n * @param {number} width \n * @param {number} height \n */\nfunction generateRectangle(x, y, width, height) {\n    return [\n        x, y,\n        x + width, y,\n        x, y + height,\n        x + width, y + height,\n        x + width, y,\n        x, y + height,\n    ]\n}\nfunction randomColor(positions) {\n    let result = [];\n    for (let i = 0; i < positions.length; i += 2) {\n        let r = Math.random();\n        let g = Math.random();\n        let b = Math.random();\n        result.push(...[r, g, b, 1]);\n    }\n    return result;\n}\n\nfunction generateRandomTriangle() {\n    let result = [];\n    for (let i = 0; i < 3; i++) {\n        let x = Math.random() * width;\n        let y = Math.random() * height;\n        result.push(x, y);\n    }\n\n    return result;\n}\n\nfunction webGLSetup() {\n    (0,_webgl_test__WEBPACK_IMPORTED_MODULE_0__.setContext)(canvas);\n    const basicProgramData = (0,_webgl_test__WEBPACK_IMPORTED_MODULE_0__.makeProgram)(document.querySelector('#pixel-vertex-shader-2d').textContent, document.querySelector('#color-fragment-shader-2d').textContent)\n    ;(0,_webgl_test__WEBPACK_IMPORTED_MODULE_0__.useProgramData)(basicProgramData);\n\n    const imageVertexSource = document.querySelector('#image-vertex-shader-2d').textContent;\n    const imageFragmentSource = document.querySelector('#image-fragment-shader-2d').textContent;\n    const imageProgramData = (0,_webgl_test__WEBPACK_IMPORTED_MODULE_0__.makeProgram)(imageVertexSource, imageFragmentSource);\n    let imgData = generateImageData();\n    let x = 0;\n    let y = 0;\n    let speed = 2;\n    let angle = Math.random() * Math.PI * 2;\n    let xVelocity = Math.cos(angle) * speed;\n    let yVelocity = Math.sin(angle) * speed;\n    window.setInterval(() => {\n        x += xVelocity;\n        y += yVelocity;\n        if (x + 64 > width || x < 0) {\n            xVelocity = - xVelocity;\n        }\n        if (y + 64 > height || y < 0) {\n            yVelocity = -yVelocity;\n        }\n        //angle += 1e-2;\n        (0,_webgl_test__WEBPACK_IMPORTED_MODULE_0__.drawImage)(imageProgramData, imgData.positions, imgData.texCoords, imgData.textureInfo.texture, imgData.textureInfo.width, imgData.textureInfo.height, Math.floor(x), Math.floor(y), 0);\n    }, 20);\n}\n\nfunction generateImageData() {\n    // unit quad\n    let positions = [\n        0, 0,\n        0, 1,\n        1, 0,\n        1, 0,\n        0, 1,\n        1, 1,\n    ];\n    // also a unit quad\n    let texCoords = [\n        0, 0,\n        0, 1,\n        1, 0,\n        1, 0,\n        0, 1,\n        1, 1,\n    ];\n    let textureInfo = (0,_webgl_test__WEBPACK_IMPORTED_MODULE_0__.loadImageAndCreateTextureInfo)('assets/test.png');\n    return {positions, texCoords, textureInfo};\n}\n\nwebGLSetup();\n/*\nlet geometry = [];\nlet color = [];\nlet rectangle = generateRectangle(0, 0, 50, 100);\nlet rectColors = randomColor(rectangle);\ndraw({a_position: rectangle, a_color: rectColors, u_resolution: [width, height]});\n*/\n/*\nwindow.setInterval(function(){\n    let newGeometry = generateRandomTriangle();\n    let newColor = randomColor(newGeometry);\n    geometry.push(...newGeometry);\n    color.push(...newColor);\n    draw({a_position: geometry, a_color: color, u_resolution: [width, height]});\n}, 500);\n\nwindow.setInterval(function(){\n    geometry = [];\n    color = [];\n    clear(clearColor);\n}, 10000);*/\n\n//# sourceURL=webpack://js-framework/./src/index.js?");

/***/ }),

/***/ "./src/matrix-util.js":
/*!****************************!*\
  !*** ./src/matrix-util.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"matrix4\": () => (/* binding */ matrix4),\n/* harmony export */   \"matrix3\": () => (/* binding */ matrix3)\n/* harmony export */ });\n\nconst M00 = 0;\nconst M01 = 1;\nconst M02 = 2;\nconst M03 = 3;\nconst M10 = 4;\nconst M11 = 5;\nconst M12 = 6;\nconst M13 = 7;\nconst M20 = 8;\nconst M21 = 9;\nconst M22 = 10;\nconst M23 = 11;\nconst M30 = 12;\nconst M31 = 13;\nconst M32 = 14;\nconst M33 = 15;\nconst matrix4 = {\n    orthographic,\n    translate,\n    scale,\n    multiply,\n    prettyPrint,\n    identity: function matrix4Identity() {\n        return [\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1,\n        ];\n    },\n};\n\nfunction matrix2Identity() {\n    return [\n        1, 0,\n        0, 1,\n    ];\n}\n\nfunction matrix3Identity() {\n    return [\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1,\n    ];\n}\n\nfunction orthographic(left, right, bottom, top, near, far) {\n    let matrix = [\n        0, 0, 0, 0,\n        0, 0, 0, 0,\n        0, 0, 0, 0,\n        0, 0, 0, 0,\n    ];\n    matrix[M00] = 2/(right-left);\n    matrix[M03] = -(right+left)/(right-left);\n    matrix[M11] = 2/(top-bottom);\n    matrix[M13] = -(top+bottom)/(top-bottom);\n    matrix[M22] = -2/(far-near);\n    matrix[M23] = -(far+near)/(far-near);\n    matrix[M33] = 1;\n\n    return matrix;\n}\n\nfunction translate(matrix, tx, ty, tz) {\n    let translationMatrix = [\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        tx, ty, tz, 1,\n    ];\n\n    return multiply(matrix, translationMatrix);\n}\n\nfunction scale(matrix, sx, sy, sz) {\n    let scaleMatrix = [\n        sx, 0,  0, 0,\n        0, sy,  0, 0,\n        0,  0, sz, 0,\n        0,  0,  0, 1,\n    ];\n\n    return multiply(matrix, scaleMatrix);\n}\n\nfunction multiply(matrix1, matrix2) {\n    function dotProduct(mat1Row, mat2Col) {\n        let product = 0;\n        for (let i = 0; i < 4; i++) {\n            product += (matrix1[i + mat1Row * 4] * matrix2[i * 4 + mat2Col]);\n        }\n        return product;\n    }\n    //assume matrix1 is always a 4x4, but matrix2 could be a 4x4 or a vec4\n    \n    if (matrix2.length === 16) {\n        let newMatrix = [\n            0, 0, 0, 0,\n            0, 0, 0, 0,\n            0, 0, 0, 0,\n            0, 0, 0, 0,\n        ];\n        // TODO: make this more succinct in a for loop?\n        newMatrix[0] = dotProduct(0, 0);\n        newMatrix[1] = dotProduct(0, 1);\n        newMatrix[2] = dotProduct(0, 2);\n        newMatrix[3] = dotProduct(0, 3);\n\n        newMatrix[4] = dotProduct(1, 0);\n        newMatrix[5] = dotProduct(1, 1);\n        newMatrix[6] = dotProduct(1, 2);\n        newMatrix[7] = dotProduct(1, 3);\n\n        newMatrix[8] = dotProduct(2, 0);\n        newMatrix[9] = dotProduct(2, 1);\n        newMatrix[10] = dotProduct(2, 2);\n        newMatrix[11] = dotProduct(2, 3);\n\n        newMatrix[12] = dotProduct(3, 0);\n        newMatrix[13] = dotProduct(3, 1);\n        newMatrix[14] = dotProduct(3, 2);\n        newMatrix[15] = dotProduct(3, 3);\n        return newMatrix;\n    }\n    else if (matrix2.length === 4) {\n        let newVector = [0, 0, 0, 0];\n        for (let index = 0; index < newVector.length; index += 1) {\n            let product = 0;\n            for (let i = 0; i < 4; i += 1) {\n                product += matrix1[i + 4*index] * matrix2[i];\n            }\n            newVector[index] = product;\n        }\n        return newVector\n    }\n    else {\n        console.log('Error! matrix4.multiply: second arg is not a 4x4 or a vec4!');\n        console.log(matrix2);\n    }\n}\n\nfunction prettyPrint(matrix) {\n    for (let i = 0; i < 4; i += 1) {\n        let str = '';\n        for (let j = 0; j < 4; j++) {\n            str += matrix[i*4 + j] + ' ';\n        }\n        console.log(str);\n    }\n}\n\nconst matrix3 = {\n    identity: function() {\n        return [\n            1, 0, 0,\n            0, 1, 0,\n            0, 0, 1,\n        ];\n    },\n    multiply: function(matrix1, matrix2) {\n        function dotProduct(mat1Row, mat2Col) {\n            let product = 0;\n            for (let i = 0; i < 3; i++) {\n                product += (matrix1[i + mat1Row * 3] * matrix2[i * 3 + mat2Col]);\n            }\n            return product;\n        }\n        if (matrix2.length === 9) {\n            let newMatrix = [\n                0, 0, 0,\n                0, 0, 0,\n                0, 0, 0,\n            ];\n            newMatrix[0] = dotProduct(0, 0);\n            newMatrix[1] = dotProduct(0, 1);\n            newMatrix[2] = dotProduct(0, 2);\n\n            newMatrix[3] = dotProduct(1, 0);\n            newMatrix[4] = dotProduct(1, 1);\n            newMatrix[5] = dotProduct(1, 2);\n\n            newMatrix[6] = dotProduct(2, 0);\n            newMatrix[7] = dotProduct(2, 1);\n            newMatrix[8] = dotProduct(2, 2);\n\n            return newMatrix;\n        } else if (matrix2.length === 3) {\n            let newVector = [0, 0, 0];\n            for (let index = 0; index < newVector.length; index += 1) {\n                let product = 0;\n                for (let i = 0; i < 3; i += 1) {\n                    product += matrix1[i + 3 * index] * matrix2[i];\n                }\n                newVector[index] = product;\n            }\n            return newVector;\n        } else {\n            console.log('Error- matrix3.multiply- second arg is neither a 3x3 or a vec3!');\n        }\n    },\n    scale: function(matrix, sx, sy) {\n        let scaleMatrix = [\n            sx, 0, 0,\n            0, sy, 0,\n            0, 0, 1,\n        ];\n        return matrix3.multiply(matrix, scaleMatrix);\n    },\n    translate: function(matrix, tx, ty) {\n        let translationMatrix = [\n            1, 0, 0,\n            0, 1, 0,\n            tx, ty, 1,\n        ];\n        return matrix3.multiply(matrix, translationMatrix);\n    },\n    rotate: function(matrix, angleInRadians) {\n        const cos = Math.cos(angleInRadians);\n        const sin = Math.sin(angleInRadians);\n        let rotationMatrix = [\n            cos, -sin, 0,\n            sin, cos, 0,\n            0, 0, 1,\n        ];\n        return matrix3.multiply(matrix, rotationMatrix);\n    },\n};\n\n\n\n//# sourceURL=webpack://js-framework/./src/matrix-util.js?");

/***/ }),

/***/ "./src/webgl-test.js":
/*!***************************!*\
  !*** ./src/webgl-test.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loadImageAndCreateTextureInfo\": () => (/* binding */ loadImageAndCreateTextureInfo),\n/* harmony export */   \"drawImage\": () => (/* binding */ drawImage),\n/* harmony export */   \"setContext\": () => (/* binding */ setContext),\n/* harmony export */   \"makeProgram\": () => (/* binding */ makeProgram),\n/* harmony export */   \"useProgramData\": () => (/* binding */ useProgramData),\n/* harmony export */   \"draw\": () => (/* binding */ draw),\n/* harmony export */   \"clear\": () => (/* binding */ clear)\n/* harmony export */ });\n/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-utils */ \"./src/webgl-utils.js\");\n/* harmony import */ var _matrix_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix-util */ \"./src/matrix-util.js\");\n\n\n;\n\n\n/** @type {WebGLRenderingContext} */\nlet gl;\nlet currentProgramData;\n\n/** \n * Setup the WebGL render context\n * @param {HTMLCanvasElement} canvas \n */\nfunction setContext(canvas) {\n    gl = canvas.getContext('webgl');\n    if (!gl) {\n        alert('Error loading WebGL!');\n    }\n}\n\n/**\n * Compile a webGL program using the given shader sources. Requires WebGL render context to be set\n * @param {string} vertexSource \n * @param {string} shaderSource\n * @returns {WebGLProgram} \n */\nfunction makeProgram(vertexSource, shaderSource) {\n    if (!gl) {\n        alert('WebGL context must be initialized before calling makeProgram!');\n    }\n    return (0,_webgl_utils__WEBPACK_IMPORTED_MODULE_0__.createProgramFromScripts)(gl, vertexSource, shaderSource);\n}\n\n/**\n * Set this to be the current active program data (object containing WebGL program and attribute/uniform info)\n * @param {*} programData \n */\nfunction useProgramData(programData) {\n    currentProgramData = programData;\n    gl.useProgram(currentProgramData.program); \n}\n\n/**\n * Clears the current canvas\n * @param {Number[]} color Color in [r, g, b, a] format\n */\nfunction clear(color) {\n    gl.clearColor(...color);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n}\n\nfunction setupAttribBuffer(attribData, values, usage) {\n    /* for every attribute:\n    *  -get the attribute location from the program (using a string)\n    *  -create the buffer\n    *  -bind the buffer\n    *  -call bufferdata with the input\n    *  -call vertexAttribPointer with the necessary information\n    */\n    let buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(values), usage);\n    gl.enableVertexAttribArray(attribData.location);\n    gl.vertexAttribPointer(attribData.location, attribData.size, attribData.type, false, 0 , 0);\n}\n\nfunction setupUniform(uniformData, values) {\n    /* for uniforms:\n    *  -get the uniform location\n    *  -set the uniform\n    *  (both are handled by the provided setter function in uniformData)\n    */\n    uniformData.setter(values);\n}\n\n/**\n *  creates texture info { width w: height: h texture: tex}\n *  texture starts with 1x1 pixels and updates when it is loaded\n * @param {*} path Location of the image\n */\nfunction loadImageAndCreateTextureInfo(path) {\n    let tex = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    // fill text with 1x1 blue pixel\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,\n        new Uint8Array([0, 0, 255, 255]));\n\n    // assume texture is not a power of 2\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n    let textureInfo = {\n        width: 1, // size is unknown until load is done\n        height: 1,\n        texture: tex,\n    };\n    let img = new Image();\n    img.addEventListener('load', function() {\n        textureInfo.width = img.width;\n        textureInfo.height = img.height;\n        \n        gl.bindTexture(gl.TEXTURE_2D, textureInfo.texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n        console.log(textureInfo);\n    });\n    \n    img.src = path;\n\n    return textureInfo;\n}\n\nfunction drawImage(imageProgramData, positions, texcoords, tex, texWidth, texHeight, dstX, dstY, angle) {\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n\n    //TODO: load in our shader program, or just remove the arg and set useProgramData from index.js\n    useProgramData(imageProgramData);\n\n    //imageProgramData.attributeData['a_position'].size = 2; //override size here, GLSL is a vec4, but we will only be providing x and y, so let it fill in default vals\n\n    setupAttribBuffer(imageProgramData.attributeData['a_position'], positions, gl.DYNAMIC_DRAW);\n    setupAttribBuffer(imageProgramData.attributeData['a_texcoord'], texcoords, gl.DYNAMIC_DRAW);\n\n    setupUniform(imageProgramData.uniformData['u_resolution'], [canvas.width, canvas.height]);\n\n    // matrix will convert from pixels to clipspace\n    let matrix = _matrix_util__WEBPACK_IMPORTED_MODULE_1__.matrix3.identity();\n\n    // this matrix scales our unit quad up to texWidth, texHeight\n    matrix = _matrix_util__WEBPACK_IMPORTED_MODULE_1__.matrix3.scale(matrix, texWidth, texHeight);\n\n    // rotation transform would go here\n    matrix = _matrix_util__WEBPACK_IMPORTED_MODULE_1__.matrix3.rotate(matrix, angle);\n\n    // this matrix will translate the quad to dstX, dstY\n    matrix = _matrix_util__WEBPACK_IMPORTED_MODULE_1__.matrix3.translate(matrix, dstX, dstY);\n\n    let matrixLocation = imageProgramData.uniformData['u_matrix'].location;\n    // set the matrix uniform\n    gl.uniformMatrix3fv(matrixLocation, false, matrix);\n\n    let textureLocation = imageProgramData.uniformData['u_texture'].location;\n    // tell shader to get texture from texture unit 0\n    gl.uniform1i(textureLocation, 0);\n\n    // draw the quad (2 triangles, so 6 vertices)\n    gl.drawArrays(gl.TRIANGLES, 0 , 6);\n\n}\n\n/**\n * Draw using the supplied values. Fails if webGL is not initialized and a program is not loaded, or if values do not match the attributes/uniforms\n */\nfunction draw(values) {\n    if (!gl) {\n        alert('WebGL context must be initialized before calling draw!');\n    }\n    \n   // iterate over each attribute, and extract the data from values\n   // presumes values has a field for each attribute name\n    Object.keys(currentProgramData.attributeData).forEach(attributeName => {\n        if (values[attributeName] === undefined) {\n            console.log(`Values not provided for attribute: ${attributeName}`);\n        }\n        else {\n            setupAttribBuffer(currentProgramData.attributeData[attributeName], values[attributeName], gl.STATIC_DRAW);\n        }\n    });\n\n    Object.keys(currentProgramData.uniformData).forEach(uniformName => {\n        if (values[uniformName] === undefined) {\n            console.log(`Values not provided for uniform: ${uniformName}`);\n        }\n        else {\n            setupUniform(currentProgramData.uniformData[uniformName], values[uniformName]);\n        }\n    });\n    \n    (0,_webgl_utils__WEBPACK_IMPORTED_MODULE_0__.resizeCanvasToDisplaySize)(gl.canvas);\n\n    // setup clip space to screen space relationship\n    // map -1, +1 to 0, width, ... etc\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    /*\n    // Tell the attribute how to get data out of positionBuffer\n    let size = 2 // 2 components per iteration\n    let type = gl.FLOAT // data is 32 bit floats\n    let normalize = false; // don't normalize the data\n    let stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position\n    let offset = 0; // start at the beginning of the buffer\n    gl.vertexAttribPointer(\n        positionAttributeLocation,\n        size,\n        type,\n        normalize,\n        stride,\n        offset\n    );*/\n\n    let primitiveType = gl.TRIANGLES; // every 3 times the shader is run, a triangle will be drawn with the 3 points\n    let offset = 0;\n    let count = values['a_position'].length / 2; // execute the vertex shader once for every pair of points provided\n    gl.drawArrays(primitiveType, offset, count);\n}\n\n\n\n//# sourceURL=webpack://js-framework/./src/webgl-test.js?");

/***/ }),

/***/ "./src/webgl-utils.js":
/*!****************************!*\
  !*** ./src/webgl-utils.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createProgramFromScripts\": () => (/* binding */ createProgramFromScripts),\n/* harmony export */   \"resizeCanvasToDisplaySize\": () => (/* binding */ resizeCanvasToDisplaySize)\n/* harmony export */ });\n\n\n/**\n * Compile shader from source\n * @param {WebGLRenderingContext} gl \n * @param {WebGLRenderingContextBase} type \n * @param {string} source \n * @returns {WebGLShader}\n */\nfunction createShader(gl, type, source) {\n    let shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success) {\n        return shader;\n    }\n\n    console.log(gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n}\n\n/**\n * Extract all attribute and uniforms in this program, and record their locations\n * @param {WebGLRenderingContext} gl \n * @param {WebGLProgram} program \n * @param {WebGLShader} vertexShaderProgram \n * @param {WebGLShader} fragmentShaderProgram \n */\nfunction extractProgramData(gl, program, vertexShaderProgram, fragmentShaderProgram) {\n    /**\n     * Process a line of GLSL code into a attribute/uniform data object\n     * @param {string} line GLSL Code to be processed\n     * @param {*} container Container to place attribute (either attributeData or uniformData)\n     * @param {boolean} isAttribute True if attribute, False if uniform\n     */\n    function processLine(line, container, isAttribute) {\n        /**\n         * Get the associated WebGL type to be used for buffers later\n         * @param {string} type \n         */\n        function getGLType(type) {\n            //TODO: add in more types\n            const glTypes = {\n                ivec: gl.SHORT,\n                uvec: gl.UNSIGNED_INT,\n                vec: gl.FLOAT,\n            };\n            return glTypes[type];\n        }\n        function getUniformSetter(fullDataType) {\n            //TODO: add in more function mappings\n            const createSetter = function(glFunc) {\n                return (values) => gl[glFunc](location, ...values);\n            }\n            const setters = {\n                vec2: createSetter('uniform2f'),\n                vec3: createSetter('uniform3f'),\n                vec4: createSetter('uniform4f'),\n            }\n            return setters[fullDataType];\n        }\n        let splitLine = line.split(' ');\n        let name = splitLine[2].split(';')[0];\n        //TODO: make type line up with proper enum; e.g. gl.FLOAT for vec, gl.DOUBLE for dmat, dvec,... etc.\n        let fullDataType = splitLine[1];\n        // regex for getting non-numeric portion\n        let dataType = fullDataType.match(/\\D/g).join('')\n        let type = getGLType(dataType);\n        // regex for getting numerics only\n        let size = Number.parseInt(fullDataType.match(/\\d+/g).join(''));\n        let location = isAttribute ? gl.getAttribLocation(program, name) : gl.getUniformLocation(program, name);\n        if (isAttribute) {\n            container[name] = {type, size, location};\n        }\n        else {\n            container[name] = {type, size, location, setter: getUniformSetter(fullDataType)}\n        }\n        \n    }\n    let vertexRaw = gl.getShaderSource(vertexShaderProgram).split('\\n').map(x => x.trimStart());\n    let fragmentRaw = gl.getShaderSource(fragmentShaderProgram).split('\\n').map(x => x.trimStart());\n    let attributeData = {};\n    let uniformData = {};\n\n    vertexRaw.forEach(line => {\n        if (line.includes('uniform')) {\n            processLine(line, uniformData, false);\n        }\n        if (line.includes('attribute')) {\n            processLine(line, attributeData, true);\n        }\n    });\n    fragmentRaw.forEach(line => {\n        if (line.includes('uniform')) {\n            // I'm assuming the GLSL compiler checks to make sure that uniforms are named properly so there's no duplicates with different types\n            processLine(line, uniformData, false);\n        }\n    });\n    return {program, attributeData, uniformData};\n}\n\n/** \n * Create a webGL program \n * @param {WebGLRenderingContext} gl \n * @param {WebGLShader} vertexShader \n * @param {WebGLShader} fragmentShader \n * @returns {WebGLProgram}\n */\nfunction createProgram(gl, vertexShader, fragmentShader) {\n    let program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    let success = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (success) {\n        return extractProgramData(gl, program, vertexShader, fragmentShader);\n    }\n\n    console.log(gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n}\n\n/**\n * Compiles GLSL program given the source code for vertex and fragment shaders\n * @param {WebGLRenderingContext} gl \n * @param {string} vertexSource \n * @param {string} fragmentSource \n */\nfunction createProgramFromScripts(gl, vertexSource, fragmentSource) {\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n    return createProgram(gl, vertexShader, fragmentShader);\n}\n\n/**\n * Resize the canvas if it is not the same size in pixels\n * @param {HTMLCanvasElement} canvas \n */\nfunction resizeCanvasToDisplaySize(canvas) {\n    // Lookup the size the browser is displaying the canvas in CSS pixels.\n    const displayWidth  = canvas.clientWidth;\n    const displayHeight = canvas.clientHeight;\n   \n    // Check if the canvas is not the same size.\n    const needResize = canvas.width  !== displayWidth ||\n                       canvas.height !== displayHeight;\n   \n    if (needResize) {\n      // Make the canvas the same size\n      canvas.width  = displayWidth;\n      canvas.height = displayHeight;\n    }\n   \n    return needResize;\n}\n\n\n\n//# sourceURL=webpack://js-framework/./src/webgl-utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;